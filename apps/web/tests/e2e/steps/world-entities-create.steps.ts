import { expect } from "@playwright/test";
import { createBdd } from "playwright-bdd";
import { ensureModeSelectorVisible, getUniqueCampaignName, waitForModalOpen, waitForModalClose, loginAs, loginAsAdmin, waitForWorldUpdated, waitForMode } from "../helpers";
import { createApiClient } from "../helpers/api";
import { STABILITY_WAIT_MEDIUM } from "../helpers/constants";
import { navigateAndWaitForReady } from "../helpers/utils";
import { safeWait } from "../helpers/utils";
import { createCreature, createFaction } from "../helpers/entityCreation";
import { navigateToCreaturesTab, navigateToFactionsTab } from "../helpers/tabs";
import { verifyEntityInList } from "../helpers/verification";
import type { Page, APIRequestContext } from "@playwright/test";

const { Given, When, Then } = createBdd();

// Helper function to ensure world exists and is selected (extracted for reuse)
export async function ensureWorldExistsAndSelected(page: Page, worldName: string): Promise<void> {
  const uniqueWorldName = 
    worldName === "Eldoria" || worldName === "NoSplashWorld" 
      ? getUniqueCampaignName(worldName) 
      : worldName;
  
  // Check if user is already logged in (don't navigate/relogin if already logged in)
  // This prevents race conditions when called after "the admin signs in to the system"
  const logoutButton = page.getByRole("button", { name: "Log out" });
  const isLoggedIn = await logoutButton.isVisible({ timeout: 3000 }).catch(() => false);
  
  if (!isLoggedIn) {
    // Only navigate and login if not already logged in
    await navigateAndWaitForReady(page);
    await loginAsAdmin(page);
  } else {
    // Already logged in - just ensure page is ready
    await page.waitForLoadState("networkidle", { timeout: 3000 }).catch(() => {});
  }
  
  // Ensure mode selector is visible (only if not already in planning mode)
  await ensureModeSelectorVisible(page);

  const worldContextTablist = page.getByRole("tablist", { name: "World context" });
  // Check for both unique name and base name (for backwards compatibility)
  let hasWorldTab = await worldContextTablist
    .getByRole("tab", { name: uniqueWorldName })
    .isVisible()
    .catch(() => false);
  
  if (!hasWorldTab && (worldName === "Eldoria" || worldName === "NoSplashWorld")) {
    // Also check for base name
    hasWorldTab = await worldContextTablist
      .getByRole("tab", { name: worldName })
      .isVisible()
      .catch(() => false);
  }

  if (!hasWorldTab) {
    // Open the Snapp menu dropdown
    const snappMenuButton = page.getByRole("button", { name: /^Snapp/i });
    await snappMenuButton.click();
    
    // Click "Create world" from the dropdown menu
    await page.getByRole("button", { name: "Create world" }).click();
    
    // Wait for modal to open using transition event
    await waitForModalOpen(page, "world", 5000);
    
    // Fill the form
    await page.getByLabel("World name").fill(uniqueWorldName);
    await page.getByLabel("Description").fill("Autogenerated world for tests.");
    
    // Submit
    const saveButton = page.getByRole("button", { name: "Save world" });
    await expect(saveButton).toBeEnabled({ timeout: 2000 });
    await saveButton.click();
    
    // Wait for either modal to close OR world to appear
    const dialog = page.getByRole("dialog", { name: "Create world" });
    try {
      await Promise.race([
        waitForModalClose(page, "world", 5000),
        expect(worldContextTablist.getByRole("tab", { name: uniqueWorldName })).toBeVisible({ timeout: 5000 }),
        expect(dialog).toBeHidden({ timeout: 5000 })
      ]);
    } catch (raceError) {
      // Race timed out - continue to check state
    }
    
    // Verify world was created
    await expect(
      worldContextTablist.getByRole("tab", { name: uniqueWorldName })
    ).toBeVisible({ timeout: 3000 });
    
    // Store the unique name in page context for other steps to use
    await page.evaluate((name) => {
      (window as any).__testWorldName = name;
    }, uniqueWorldName);
  } else {
    // World already exists - store the name we found
    const foundName = hasWorldTab ? uniqueWorldName : worldName;
    await page.evaluate((name) => {
      (window as any).__testWorldName = name;
    }, foundName);
  }
  
  // Now select the world
  let finalWorldName = uniqueWorldName;
  if (worldName === "Eldoria" || worldName === "NoSplashWorld") {
    try {
      const storedName = await page.evaluate(() => {
        return (window as any).__testWorldName;
      });
      if (storedName) {
        finalWorldName = storedName;
      }
    } catch {
      // Use uniqueWorldName we already have
    }
  }

  // Try unique name first, then fall back to base name
  let worldTab = worldContextTablist.getByRole("tab", { name: finalWorldName });
  let exists = await worldTab.isVisible().catch(() => false);
  
  if (!exists && (worldName === "Eldoria" || worldName === "NoSplashWorld")) {
    // Fall back to base name for backwards compatibility
    worldTab = worldContextTablist.getByRole("tab", { name: worldName });
    exists = await worldTab.isVisible().catch(() => false);
  }
  
  if (exists) {
    // Check if we're already in planning mode with this world selected
    const planningTabsCheck = page.getByRole("tablist", { name: "World views" });
    const alreadyInPlanningMode = await planningTabsCheck.isVisible({ timeout: 1000 }).catch(() => false);
    
    if (alreadyInPlanningMode) {
      // Check if this world is already selected by checking the heading
      const heading = page.locator('h3.snapp-heading').first();
      const headingText = await heading.textContent().catch(() => "");
      if (headingText && (headingText.includes(finalWorldName) || headingText.includes(worldName))) {
        // Already have the correct world selected in planning mode - we're done
        // For "NoSplashWorld", ensure it has no splash image (skip to that check)
        if (worldName === "NoSplashWorld") {
          // Wait for the world header to render - wait for settings button to be visible
          const settingsButton = page.getByRole("button", { name: "World settings" });
          await expect(settingsButton).toBeVisible({ timeout: 5000 });
        }
        return;
      }
    }
    
    // Retry logic for world selection and mode activation
    let modeActivated = false;
    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt < 3; attempt++) {
      try {
        // Set up event listener BEFORE clicking
        const modePromise = waitForMode(page, 10000);
        
        await worldTab.click();
        
        // Wait for mode to activate (event-based)
        // Note: waitForMode already verifies tabs are visible internally
        // Increased timeout since worlds created via API may need more time to load
        await modePromise;
        modeActivated = true;
        break;
      } catch (error) {
        lastError = error as Error;
        
        // If mode doesn't activate, check if we're actually in the appropriate mode
        // (maybe the event didn't fire but the UI updated)
        const tabsAfterClick = page.getByRole("tablist", { name: "World views" });
        const tabsVisible = await tabsAfterClick.isVisible({ timeout: 3000 }).catch(() => false);
        if (tabsVisible) {
          // Tabs are visible even though event didn't fire - that's okay
          modeActivated = true;
          break;
        }
        
        // If this isn't the last attempt, wait a bit and try again
        if (attempt < 2) {
          await safeWait(page, STABILITY_WAIT_MEDIUM);
          // Re-find the world tab in case the UI updated
          worldTab = worldContextTablist.getByRole("tab", { name: finalWorldName });
          if (!(await worldTab.isVisible().catch(() => false))) {
            worldTab = worldContextTablist.getByRole("tab", { name: worldName });
          }
        }
      }
    }
    
    if (!modeActivated && lastError) {
      throw lastError;
    }
    
    // For "NoSplashWorld", ensure it has no splash image
    if (worldName === "NoSplashWorld") {
      // Wait for the world header to render - wait for settings button to be visible
      const settingsButton = page.getByRole("button", { name: "World settings" });
      const settingsVisible = await settingsButton.isVisible({ timeout: 3000 }).catch(() => false);
      
      if (settingsVisible) {
        // Check if there's an image in the world header (indicates splash image is set)
        // Look for img element near the settings button
        const worldHeaderArea = page.locator("section").filter({ has: settingsButton }).first();
        const hasImage = await worldHeaderArea.locator("img").first().isVisible().catch(() => false);
        
        if (hasImage) {
          // World has a splash image - open settings to clear it
          await settingsButton.click();
          await expect(page.getByRole("dialog", { name: "World Settings" })).toBeVisible({ timeout: 3000 });
          
          // Find and click the Clear button
          const clearButton = page.getByRole("button", { name: "Clear" });
          await expect(clearButton).toBeVisible({ timeout: 2000 });
          
          // Set up event listeners BEFORE clicking Clear
          // Reduced timeout from 10000ms to 5000ms for better performance
          const worldUpdatedPromise = waitForWorldUpdated(page, undefined, "splashImageCleared", 5000);
          
          // Click Clear - this should trigger setWorldSettingsOpen(false) and close the modal
          await clearButton.click();
          
          // Wait for world update event (splash image cleared)
          // The modal should close automatically, but we care more about the world update
          await worldUpdatedPromise.catch(() => {
            // If event doesn't fire, that's okay - the important thing is the splash is cleared
            // which will be verified later in the test
          });
        }
        // If no image, no need to open settings - world already has no splash image
      }
    }
  } else {
    // If neither exists, try to click anyway (might be in DOM but not visible)
    await worldTab.click({ force: true }).catch(() => {
      throw new Error(`World "${worldName}" (or "${finalWorldName}") not found`);
    });
  }
}
// Note: "the admin navigates to the World Entities planning screen" is defined in world-create.steps.ts

When("world {string} exists", async ({ page, request }, worldName: string) => {
  // Make world name unique per worker to avoid conflicts when tests run in parallel
  const uniqueWorldName = 
    worldName === "Eldoria" || worldName === "NoSplashWorld" 
      ? getUniqueCampaignName(worldName) 
      : worldName;
  
  if (!uniqueWorldName || uniqueWorldName.trim() === "") {
    throw new Error(`Invalid world name: "${worldName}" resulted in empty unique name`);
  }
  
  // Detect if we should use API (Background) or UI (scenario)
  // If page hasn't been navigated yet (URL is about:blank or empty), we're likely in Background
  // Also check if page is closed or not ready - if so, use API
  let useApi = false;
  try {
    const currentUrl = page.url();
    useApi = (currentUrl === "about:blank" || currentUrl === "") && !!request;
  } catch {
    // If we can't get the URL (page might be closed), use API if request is available
    useApi = !!request;
  }
  
  if (useApi) {
    // API-based creation (for Background - no UI interaction)
    try {
      // Get admin token for API calls
      const api = createApiClient(request!);
      const adminToken = await api.getAdminToken();
      
      // Check if world already exists
      try {
        const worldsResponse = await api.call("world", "GET", "/worlds", { token: adminToken });
        const worlds = worldsResponse.worlds || [];
        const existingWorld = worlds.find((w: any) => w.name === uniqueWorldName);
        if (existingWorld) {
          // World exists - store the name and return
          await page.evaluate((name) => {
            (window as any).__testWorldName = name;
          }, uniqueWorldName);
          return;
        }
      } catch {
        // If GET fails, try to create anyway
      }
      
      // Create world via API
      const createResponse = await api.call("world", "POST", "/worlds", {
        token: adminToken,
        body: { name: uniqueWorldName, description: "Autogenerated world for tests." }
      });
      
      // Response format: { world: World }
      const createdWorld = (createResponse as { world?: any }).world;
      if (!createdWorld) {
        throw new Error("World creation response missing world data");
      }
      
      // Store the unique name in page context for other steps to use
      await page.evaluate((name) => {
        (window as any).__testWorldName = name;
      }, uniqueWorldName);
    } catch (err) {
      const error = err as Error;
      if (error.message.includes("Cannot connect") || error.message.includes("ECONNREFUSED")) {
        throw new Error(
          `Cannot connect to world service at ${WORLD_SERVICE_URL}. Ensure the world service is running.`
        );
      }
      // If world already exists (409), that's fine - just store the name
      if (error.message.includes("409") || error.message.includes("already exists")) {
        await page.evaluate((name) => {
          (window as any).__testWorldName = name;
        }, uniqueWorldName);
        return;
      }
      throw err;
    }
    return;
  }
  
  // UI-based creation (for scenarios)
  // Ensure user is logged in first
  // If called from Background, ensure page is ready first
  await navigateAndWaitForReady(page);
  
  const logoutButton = page.getByRole("button", { name: "Log out" });
  const isLoggedIn = await logoutButton.isVisible({ timeout: 2000 }).catch(() => false);
  if (!isLoggedIn) {
    await loginAsAdmin(page);
  }
  
  await ensureModeSelectorVisible(page);

  const worldContextTablist = page.getByRole("tablist", { name: "World context" });
  // Check for both unique name and base name (for backwards compatibility)
  let hasWorldTab = await worldContextTablist
    .getByRole("tab", { name: uniqueWorldName })
    .isVisible()
    .catch(() => false);
  
  if (!hasWorldTab && (worldName === "Eldoria" || worldName === "NoSplashWorld")) {
    // Also check for base name
    hasWorldTab = await worldContextTablist
      .getByRole("tab", { name: worldName })
      .isVisible()
      .catch(() => false);
  }

  if (!hasWorldTab) {
    // Open the Snapp menu dropdown
    const snappMenuButton = page.getByRole("button", { name: /^Snapp/i });
    await snappMenuButton.click();
    
    // Click "Create world" from the dropdown menu
    await page.getByRole("button", { name: "Create world" }).click();
    
    // Wait for modal to open using transition event
    await waitForModalOpen(page, "world", 5000);
    
    // Fill the form
    await page.getByLabel("World name").fill(uniqueWorldName);
    await page.getByLabel("Description").fill("Autogenerated world for tests.");
    
    // Submit
    const saveButton = page.getByRole("button", { name: "Save world" });
    await expect(saveButton).toBeEnabled({ timeout: 2000 });
    await saveButton.click();
    
    // Wait for either modal to close OR world to appear
    const dialog = page.getByRole("dialog", { name: "Create world" });
    try {
      await Promise.race([
        waitForModalClose(page, "world", 5000),
        expect(worldContextTablist.getByRole("tab", { name: uniqueWorldName })).toBeVisible({ timeout: 5000 }),
        expect(dialog).toBeHidden({ timeout: 5000 })
      ]);
    } catch (raceError) {
      // Race timed out - continue to check state
    }
    
    // Verify world was created
    await expect(
      worldContextTablist.getByRole("tab", { name: uniqueWorldName })
    ).toBeVisible({ timeout: 3000 });
    
    // Store the unique name in page context for other steps to use
    await page.evaluate((name) => {
      (window as any).__testWorldName = name;
    }, uniqueWorldName);
  } else {
    // World already exists - store the name we found
    const foundName = hasWorldTab ? uniqueWorldName : worldName;
    await page.evaluate((name) => {
      (window as any).__testWorldName = name;
    }, foundName);
    
    // For "NoSplashWorld", ensure it has no splash image
    // We'll clear it when the world is selected in the next step
    // (This avoids complex state management here)
  }
});

When("world {string} exists and is selected", async ({ page }, worldName: string) => {
  await ensureWorldExistsAndSelected(page, worldName);
});

Given("world {string} has no splash image", async ({ page, request }, worldName: string) => {
  // This step ensures the world has a placeholder (no custom splash image set)
  // The placeholder is the default state when no splash image is configured
  // Make world name unique per worker
  const uniqueWorldName = 
    worldName === "Eldoria" || worldName === "NoSplashWorld" 
      ? getUniqueCampaignName(worldName) 
      : worldName;
  
  // Detect if we should use API (Background) or UI (scenario)
  let useApi = false;
  try {
    const currentUrl = page.url();
    useApi = (currentUrl === "about:blank" || currentUrl === "") && !!request;
  } catch {
    useApi = !!request;
  }
  
  if (useApi) {
    // API-based: Ensure world exists first, then ensure it has no splash image (placeholder state)
    try {
      const api = createApiClient(request!);
      const adminToken = await api.getAdminToken();
      
      // Ensure world exists - create it if it doesn't
      let world;
      try {
        const worldsResponse = await api.call("world", "GET", "/worlds", { token: adminToken });
        const worlds = (worldsResponse as { worlds?: any[] }).worlds || [];
        world = worlds.find((w: any) => w.name === uniqueWorldName);
      } catch {
        // If GET fails, try to create the world
      }
      
      if (!world) {
        // World doesn't exist - create it without a splash image (will show placeholder)
        const createResponse = await api.call("world", "POST", "/worlds", {
          token: adminToken,
          body: { name: uniqueWorldName, description: "Autogenerated world for tests." }
        });
        world = (createResponse as { world?: any }).world;
      }
      
      // Ensure the world has no splash image (clear it if it exists, so placeholder shows)
      if (world && world.splashImageId) {
        await api.call("world", "PATCH", `/worlds/${world.id}`, {
          token: adminToken,
          body: { splashImageId: null }
        });
      }
      
      // Store the unique name for later steps
      await page.evaluate((name) => {
        (window as any).__testWorldName = name;
      }, uniqueWorldName);
    } catch (error) {
      // If API call fails, log but continue - UI step will handle it
      console.warn(`Failed to ensure world has placeholder splash image via API: ${error}`);
    }
  } else {
    // UI-based: Ensure world exists and ensure it shows placeholder (no custom splash image)
    await ensureWorldExistsAndSelected(page, worldName);
    
    // Check if the world has a custom splash image and clear it if it does (to show placeholder)
    const settingsButton = page.getByRole("button", { name: "World settings" });
    const settingsVisible = await settingsButton.isVisible({ timeout: 2000 }).catch(() => false);
    
    if (settingsVisible) {
      // Check if there's a custom splash image in the world header
      const worldHeaderArea = page.locator("section").filter({ has: settingsButton }).first();
      const hasCustomImage = await worldHeaderArea.locator("img").first().isVisible().catch(() => false);
      
      if (hasCustomImage) {
        // World has a custom splash image - open settings to clear it (so placeholder shows)
        await settingsButton.click();
        await expect(page.getByRole("dialog", { name: "World Settings" })).toBeVisible({ timeout: 3000 });
        
        // Find and click the Clear button
        const clearButton = page.getByRole("button", { name: "Clear" });
        await expect(clearButton).toBeVisible({ timeout: 2000 });
        
        // Set up event listeners BEFORE clicking Clear
        const worldUpdatedPromise = waitForWorldUpdated(page, undefined, "splashImageCleared", 5000);
        
        // Click Clear - this removes the custom image and shows the placeholder
        await clearButton.click();
        
        // Wait for world update event (splash image cleared, placeholder will show)
        await worldUpdatedPromise.catch(() => {
          // If event doesn't fire, that's okay - the important thing is the placeholder will show
        });
      }
      // If no custom image, the placeholder is already showing - nothing to do
    }
  }
});

When("the admin selects world {string}", async ({ page }, worldName: string) => {
  // Ensure user is logged in first
  // If called from Background, ensure page is ready first
  await navigateAndWaitForReady(page);
  
  const logoutButton = page.getByRole("button", { name: "Log out" });
  const isLoggedIn = await logoutButton.isVisible({ timeout: 2000 }).catch(() => false);
  if (!isLoggedIn) {
    await loginAsAdmin(page);
  }
  
  await ensureModeSelectorVisible(page);

  // Get the unique world name if it was stored, otherwise generate it (for "Eldoria" and "NoSplashWorld")
  let uniqueWorldName = worldName;
  if (worldName === "Eldoria" || worldName === "NoSplashWorld") {
    try {
      const storedName = await page.evaluate(() => {
        return (window as any).__testWorldName;
      });
      if (storedName) {
        uniqueWorldName = storedName;
      } else {
        uniqueWorldName = getUniqueCampaignName(worldName);
      }
    } catch {
      uniqueWorldName = getUniqueCampaignName(worldName);
    }
  }

  const worldContextTablist = page.getByRole("tablist", { name: "World context" });
  // Try unique name first, then fall back to base name
  let worldTab = worldContextTablist.getByRole("tab", { name: uniqueWorldName });
  let exists = await worldTab.isVisible().catch(() => false);
  
  if (!exists && (worldName === "Eldoria" || worldName === "NoSplashWorld")) {
    // Fall back to base name for backwards compatibility
    worldTab = worldContextTablist.getByRole("tab", { name: worldName });
    exists = await worldTab.isVisible().catch(() => false);
  }
  
  if (exists) {
    // Set up event listener BEFORE clicking
    const modePromise = waitForMode(page, 5000);
    
    await worldTab.click();
    
    // Wait for mode to activate (event-based)
    await modePromise;
    
    // Note: waitForMode already verifies tabs are visible internally
    
    // For "NoSplashWorld", ensure it has no splash image
    if (worldName === "NoSplashWorld") {
      // Wait for the world header to render - wait for settings button to be visible
      const settingsButton = page.getByRole("button", { name: "World settings" });
      const settingsVisible = await settingsButton.isVisible({ timeout: 3000 }).catch(() => false);
      
      if (settingsVisible) {
        // Check if there's an image in the world header (indicates splash image is set)
        // Look for img element near the settings button
        const worldHeaderArea = page.locator("section").filter({ has: settingsButton }).first();
        const hasImage = await worldHeaderArea.locator("img").first().isVisible().catch(() => false);
        
        if (hasImage) {
          // World has a splash image - open settings to clear it
          await settingsButton.click();
          await expect(page.getByRole("dialog", { name: "World Settings" })).toBeVisible({ timeout: 3000 });
          
          // Find and click the Clear button
          const clearButton = page.getByRole("button", { name: "Clear" });
          await expect(clearButton).toBeVisible({ timeout: 2000 });
          
          // Set up event listeners BEFORE clicking Clear
          // Reduced timeout from 10000ms to 5000ms for better performance
          const worldUpdatedPromise = waitForWorldUpdated(page, undefined, "splashImageCleared", 5000);
          
          // Click Clear - this should trigger setWorldSettingsOpen(false) and close the modal
          await clearButton.click();
          
          // Wait for world update event (splash image cleared)
          // The modal should close automatically, but we care more about the world update
          await worldUpdatedPromise.catch(() => {
            // If event doesn't fire, that's okay - the important thing is the splash is cleared
            // which will be verified later in the test
          });
        }
        // If no image, no need to open settings - world already has no splash image
      }
      
      // Note: We don't strictly verify the modal is closed here because:
      // 1. The Clear button should close it automatically (calls setWorldSettingsOpen(false))
      // 2. If there's a React state timing issue, the modal might still be visible
      // 3. The important thing is that the splash image is cleared, which will be verified
      //    by the test's "Then" step checking for the placeholder
      // 4. If the world still has a splash image, the test will fail later
    }
  } else {
    // If neither exists, try to click anyway (might be in DOM but not visible)
    await worldTab.click({ force: true }).catch(() => {
      throw new Error(`World "${worldName}" (or "${uniqueWorldName}") not found`);
    });
  }
});

// Combined step: world exists and is selected with creatures tab
When("world {string} exists and is selected with creatures tab", async ({ page }, worldName: string) => {
  await ensureWorldExistsAndSelected(page, worldName);
  await navigateToCreaturesTab(page);
});

// Combined step: world exists and is selected with factions tab
When("world {string} exists and is selected with factions tab", async ({ page }, worldName: string) => {
  await ensureWorldExistsAndSelected(page, worldName);
  await navigateToFactionsTab(page);
});

When('the admin ensures creature {string} exists', async ({ page }, creatureName: string) => {
  await createCreature(page, creatureName, `A creature named ${creatureName}.`);
});

Then('creature "Dragon" appears in the creatures list', async ({ page }) => {
  await verifyEntityInList(page, "Dragon");
});

When("the admin navigates to the factions tab", async ({ page }) => {
  await navigateToFactionsTab(page);
});

When('the admin ensures faction {string} exists', async ({ page }, factionName: string) => {
  await createFaction(page, factionName, "A faction.");
});

When('the admin creates faction {string}', async ({ page }, factionName: string) => {
  // Check if faction already exists
  const hasFaction = await page
    .getByRole("listitem")
    .filter({ hasText: factionName })
    .first()
    .isVisible()
    .catch(() => false);
  
  if (hasFaction) {
    // Faction already exists, skip creation
    return;
  }
  
  // Navigate to factions tab if not already there
  const addFactionButton = page.getByRole("button", { name: "Add faction" });
  const isOnFactionsTab = await addFactionButton.isVisible({ timeout: 1000 }).catch(() => false);
  
  if (!isOnFactionsTab) {
    await page.getByRole("tab", { name: "Factions" }).click();
    await expect(addFactionButton).toBeVisible();
  }
  
  // Open the create faction dialog
  await addFactionButton.click();
  const dialog = page.getByRole("dialog", { name: "Add faction" });
  await expect(dialog).toBeVisible();
  
  // Fill in faction name
  await dialog.getByLabel("Faction name").fill(factionName);
  await dialog.getByLabel("Summary").fill("A faction.");
  
  // Save the faction
  await dialog.getByRole("button", { name: "Save faction" }).click();
  
  // Wait for the dialog to close
  await expect(dialog).not.toBeVisible({ timeout: 3000 });
  
  // Wait for the faction to appear in the list
  await expect(
    page.getByRole("listitem").filter({ hasText: factionName }).first()
  ).toBeVisible({ timeout: 3000 });
});

Then('faction "Order of the Flame" appears in the factions list', async ({ page }) => {
  await verifyEntityInList(page, "Order of the Flame");
});
